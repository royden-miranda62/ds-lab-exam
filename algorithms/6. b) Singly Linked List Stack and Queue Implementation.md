# Question
Write a program to implement single linked lists to simulate stack & queue operations.

---
# Declarations
`#include <stdio.h>`  
`#include <stdlib.h>`

```
typedef struct Node
{
    int data;
    struct Node *next;
} Node;
```

`Node *stack = NULL, *queue = NULL;`


# Functions
## 1. `Node *createNode(item)`
### Algorithm
- Step 1: Allocate memory for new node using the `malloc()` function.
	- if memory allocation fails, print an error message and exit the program.
	- else, continue with the function.
- Step 2: Assign `value` to the data of the new node.
- Step 3: Set the next node of the new node as null.
	- i.e. the new node does not point to any other node.
- Step 4: Return the new node.
### Code

``` c
Node *createNode(int value)
{
    Node *newNode = (Node *)malloc(sizeof(Node)); // allocate memory for the node
    // node is typecasted to a pointer

    if (newNode == NULL)
    {
        printf("Error: Memory allocation failed.\n");
        exit(1);
    }

    newNode->data = value;
    newNode->next = NULL;

    return newNode;
}
```

## 2. `void push(**head, item)`
### Algorithm
- Step 1: Create a new node with `item` as its data value.
- Step 2: Point the new node to `head`.
- Step 3: Make the new node the new head node.
- Step 4: Print an "pushed to stack" statement.
### Code

``` c
void push(Node **head, int item)
{
    Node *newNode = createNode(item);

    newNode->next = *head;
    *head = newNode;

    printf("Pushed %d to stack.\n", item);
}
```

## 3. `void pop(**head)`
### Algorithm
- Step 1: If the list is empty, print an "underflow" statement and return control.
- Step 2: If the list contains some nodes,
	- create a temporary node pointer and assign `head` to it.
	- make the node after the temporary node the new head node.
	- print a "deleted from stack" message
	- free the memory at the temporary node's address.
### Code

``` c
void pop(Node **head)
{
    if (*head == NULL)
    {
        printf("Stack underflow. Cannot delete.\n");
        return;
    }

    Node *tempNode = *head;
    *head = tempNode->next;

    printf("Popped %d from stack.\n", tempNode->data);
    free(tempNode);
}
```

## 4. `void displayStack(*head)`
### Algorithm
- Step 1: If the list is empty, print an "empty" statement and return control.
- Step 2: If the list contains some nodes,
	- create a traversal node pointer and assign `head` to it.
	- traverse through the list and print the data values of all the node one by one.
	- print null as the last value in the stack.
### Code

``` c
void displayStack(Node *head)
{
    if (head == NULL)
    {
        printf("\nStack is empty.\n");
        return;
    }

    printf("\nStack nodes (top to bottom): \n");
    Node *temp = head;
    while (temp != NULL)
    {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n\n");
}
```

## 5. `void enqueue(**head, item)`
### Algorithm
- Step 1: Create a new node with `item` as its data value.
- Step 2: If the list is empty, make the new node the head node.
	- print an "inserted at rear" statement.
- Step 3: If the list contains some nodes,
	- create a traversal pointer and assign `head` to it.
	- traverse through the list till the last node is reached.
	- make the traversal node point to the new node.
	- print an "inserted at rear" statement.
### Code

``` c
void enqueue(Node **head, int item)
{
    Node *newNode = createNode(item);

    if (*head == NULL)
    {
        *head = newNode;
        printf("Inserted %d at rear (first node).\n", item);
        return;
    }

    Node *lastNode = *head;
    while (lastNode->next != NULL)
        lastNode = lastNode->next;

    lastNode->next = newNode;
    printf("Inserted %d at rear.\n", item);
}
```

## 6. `void dequeue(**head)`
### Algorithm
- Step 1: If the list is empty, print an "underflow" statement.
- Step 2: If the list contains some nodes,
	- create a temporary node and assign `head` to it.
	- make the node after `head` the new head node.
	- free the memory at the temporary node's address.
	- print a "deleted from front" statement.
### Code

``` c
void dequeue(Node **head)
{
    if (*head == NULL)
    {
        printf("Queue underflow. Cannot delete.\n");
        return;
    }

    Node *tempNode = *head;
    *head = (*head)->next;
    printf("Deleted %d from front.\n", tempNode->data);
    free(tempNode);
}
```

## 7. `void displayQueue(*head)`
### Code
- Step 1: If the list is empty, print an "empty list" statement and return control.
- Step 2: If the list contains some nodes,
	- create a temporary node and assign `head` to it.
	- traverse through the list and print the data values of all the nodes one by one


# Complete Program

``` c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
    int data;
    struct Node *next;
} Node;

Node *stack = NULL, *queue = NULL; // declaring a stack and a queue linked list

// create a node
Node *createNode(int value)
{
    Node *newNode = (Node *)malloc(sizeof(Node));

    if (newNode == NULL)
    {
        printf("Error: Memory allocation failed.\n");
        exit(1);
    }

    newNode->data = value;
    newNode->next = NULL;

    return newNode;
}

// insert a node into the stack
void push(Node **head, int item)
{
    Node *newNode = createNode(item);

    newNode->next = *head;
    *head = newNode;

    printf("Pushed %d to stack.\n", item);
}

// delete a node from the stack
void pop(Node **head)
{
    if (*head == NULL)
    {
        printf("Stack underflow. Cannot delete.\n");
        return;
    }

    Node *tempNode = *head;
    *head = tempNode->next;

    printf("Popped %d from stack.\n", tempNode->data);
    free(tempNode);
}

// display all the nodes in the stack
void displayStack(Node *head)
{
    if (head == NULL)
    {
        printf("\nStack is empty.\n");
        return;
    }

    printf("\nStack nodes (top to bottom): \n");
    Node *temp = head;
    while (temp != NULL)
    {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n\n");
}

// insert a node into the queue
void enqueue(Node **head, int item)
{
    Node *newNode = createNode(item);

    if (*head == NULL)
    {
        *head = newNode;
        printf("Inserted %d at rear (first node).\n", item);
        return;
    }

    Node *lastNode = *head;
    while (lastNode->next != NULL)
        lastNode = lastNode->next;

    lastNode->next = newNode;
    printf("Inserted %d at rear.\n", item);
}

// delete a node from the queue
void dequeue(Node **head)
{
    if (*head == NULL)
    {
        printf("Queue underflow. Cannot delete.\n");
        return;
    }

    Node *tempNode = *head;
    *head = (*head)->next;
    printf("Deleted %d from front.\n", tempNode->data);
    free(tempNode);
}

// display all the nodes in the queue
void displayQueue(Node *head)
{
    if (head == NULL)
    {
        printf("\nQueue is empty.\n");
        return;
    }

    printf("\nQueue nodes (front to rear): \n");
    Node *temp = head;
    while (temp != NULL)
    {
        printf("%d", temp->data);

        if (temp->next != NULL)
            printf(" -> ");
        else
            printf("");

        temp = temp->next;
    }
    printf("\n\n");
}

int main()
{
    printf("--- Stack Operations ---\n");
    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    displayStack(stack);

    pop(&stack);
    pop(&stack);
    pop(&stack);
    pop(&stack);

    printf("\n--- Queue Operations ---\n");
    enqueue(&queue, 1);
    enqueue(&queue, 2);
    enqueue(&queue, 3);

    displayQueue(queue);

    dequeue(&queue);
    dequeue(&queue);
    dequeue(&queue);
    dequeue(&queue);

    return 0;
}
```

## Output

```
--- Stack Operations ---
Pushed 10 to stack.
Pushed 20 to stack.
Pushed 30 to stack.

Stack nodes (top to bottom):
30 -> 20 -> 10 -> NULL

Popped 30 from stack.
Popped 20 from stack.
Popped 10 from stack.
Stack underflow. Cannot delete.

--- Queue Operations ---
Inserted 1 at rear (first node).
Inserted 2 at rear.
Inserted 3 at rear.

Queue nodes (front to rear):
1 -> 2 -> 3

Deleted 1 from front.
Deleted 2 from front.
Deleted 3 from front.
Queue underflow. Cannot delete.
```


