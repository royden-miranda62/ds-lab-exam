# Question
Write a program to simulate the working of a circular queue of integers using an array.  
Provide the following operations: Insert, Delete & Display  
The program should print appropriate messages for queue empty and queue overflow conditions.


# Declarations
`#include <stdio.h>`  
`#include <stdbool.h>`

`#define SIZE 5`

`int cirQueue[SIZE];` : declares an integer array as a circular queue.  
`int front = -1, rear = -1;`

> [!info] Note  
> Pointers are incremented in a circular queue using the formula `x = (x + 1) % SIZE`.


# Functions
## 1. `void enqueue(item)`
### Algorithm
- Step 1: Check if the queue is full.
	- if so, print an "overflow" statement and return control.
	- else, continue with the function.
- Step 2: If the queue is empty (if `front` is -1), initialize the front and rear pointers to 0.
- Step 3: If the queue is not empty, increment the rear pointer.
- Step 4: Assign `item` as the new rear element.
- Step 5: Print an "inserted" statement.
### Code

``` c
void enqueue(int item)
{
    if (isFull())
    {
        printf("Queue overflow. Cannot insert %d.\n", item);
        return;
    }

    if (front == -1)
        front = rear = 0; // initialize the front and rear pointers for the first element
    else
        rear = (rear + 1) % SIZE; // move the rear pointer to the next position

    cirQueue[rear] = item;
    printf("Inserted %d at the rear.\n", item);
}
```

## 2. `void dequeue()`
### Algorithm
- Step 1: Check if the queue is empty.
	- if so, print an "underflow" statement and return control.
	- else, continue with the function.
- Step 2: Print the element at the front with a "deleted" statement.
	- alternatively, assign it to a variable and then print it with a "deleted" statement.
- Step 3: If the queue is now empty (i.e. if the only element in the queue was deleted), reset the front and rear pointers to -1.
- Step 4: If there are still elements left in the queue, increment the front pointer.
### Code

``` c
void dequeue()
{
    if (isEmpty())
    {
        printf("Underflow. Cannot delete.\n");
        return;
    }

    printf("Deleted %d from the front.\n", cirQueue[front]);

    if (front == rear)
        front = rear = -1;          // reset front and rear pointers
    else
        front = (front + 1) % SIZE; // move front pointer to next position
}
```

## 3. `void display()`
### Algorithm
- Step 1: Check if the queue is empty.
	- if so, print an "empty" statement and return control.
	- else, continue with the function.
- Step 2: Initialize a loop variable (`i`) with the value of the front pointer.
- Step 3: Loop through the queue while `i` is not equal to `(rear + 1) % SIZE` .
	- print all the elements one by one and increment `i`.
### Code

``` c
void display()
{
    if (isEmpty())
    {
        printf("\nQueue is empty.\n");
        return;
    }

    printf("\nCircular queue elements: \n");
    int i = front;
    printf("|");
    do
    {
        printf(" %d |", cirQueue[i]);
        i = (i + 1) % SIZE;
    } while (i != (rear + 1) % SIZE);
    printf("\n\n");
}
```


# Complete Program
``` c
#include <stdio.h>
#include <stdbool.h>

#define SIZE 5

int cirQueue[SIZE];
int front = -1, rear = -1;

// check if the queue is full
bool isFull()
{
    return ((rear + 1) % SIZE == front);
}

// check if the queue is empty
bool isEmpty()
{
    return (front == -1);
}

// insert an element into the queue
void enqueue(int item)
{
    if (isFull())
    {
        printf("Queue overflow. Cannot insert %d.\n", item);
        return;
    }

    // if queue is empty
    if (front == -1)
        front = rear = 0; // initialize front and rear pointers for first element
    // if some elements are already in queue
    else
        rear = (rear + 1) % SIZE; // move rear pointer to next position
    // if rear at end (SIZE - 1), reset to 0 after insertion
    // (SIZE - 1 + 1) % SIZE = SIZE % SIZE = 0

    cirQueue[rear] = item;
    printf("Inserted %d at the rear.\n", item);
}

// delete an element from the queue
void dequeue()
{
    if (isEmpty())
    {
        printf("Underflow. Cannot delete.\n");
        return;
    }

    printf("Deleted %d from the front.\n", cirQueue[front]);

    if (front == rear)              // if queue now empty
        front = rear = -1;          // reset front and rear pointers
    else                            // if elements remain
        front = (front + 1) % SIZE; // move front pointer to next position
}

// display the elements in the queue
void display()
{
    if (isEmpty())
    {
        printf("\nQueue is empty.\n");
        return;
    }

    printf("\nCircular queue elements: \n");
    int i = front;
    printf("|");
    do
    {
        printf(" %d |", cirQueue[i]);
        i = (i + 1) % SIZE;
    } while (i != (rear + 1) % SIZE);
    printf("\n\n");
}

int main()
{
    printf("----- Circular Queue Operations -----\n");
    printf("Size of circular queue = %d\n", SIZE);

    printf("\n--- Enqueue ---\n");
    enqueue(5);
    enqueue(10);
    enqueue(15);
    enqueue(20);
    enqueue(25);
    enqueue(30);

    display();

    printf("\n--- Dequeue ---\n");
    dequeue();
    dequeue();
    dequeue();

    display();

    dequeue();
    dequeue();
    dequeue();

    display();

    return 0;
}
```

## Output
```
----- Circular Queue Operations -----
Size of circular queue = 5

--- Enqueue ---
Inserted 5 at the rear.
Inserted 10 at the rear.
Inserted 15 at the rear.
Inserted 20 at the rear.
Inserted 25 at the rear.
Queue overflow. Cannot insert 30.

Circular queue elements:
| 5 | 10 | 15 | 20 | 25 |


--- Dequeue ---
Deleted 5 from the front.
Deleted 10 from the front.
Deleted 15 from the front.

Circular queue elements:
| 20 | 25 |

Deleted 20 from the front.
Deleted 25 from the front.
Underflow. Cannot delete.

Queue is empty.
```


