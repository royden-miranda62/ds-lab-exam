# Question
Write a program to implement a doubly linked list with primitive operations  
a) Create a doubly linked list.  
b) Insert a new node to the left of the node.  
c) Delete the node based on a specific value.  
d) Display the contents of the list.


# Declarations
`#include <stdio.h>`  
`#include <stdlib.h>`

Node implementation:

```
typedef struct Node
{
    int data;
    struct Node *prev;
    struct Node *next;
} Node;
```


# Functions
## 1. `Node *createNode(value)`
### Algorithm
- Step 1: Allocate memory for a new node using the `malloc()` function.
	- if memory allocation fails, print an error message and exit the program.
	- else, continue with the function.
- Step 2: Assign `value` to the data of the new node.
- Step 3: Set the previous and next nodes of the new node as null.
	- i.e. the new node does not point to any other node.
- Step 4: Return the new node.
### Code

```c 
Node *createNode(int item)
{
    Node *newNode = (Node *)malloc(sizeof(Node));

    if (newNode == NULL)
    {
        printf("Error:Memory allocation failed.\n");
        exit(1);
    }

    newNode->data = item;
    newNode->prev = NULL;
    newNode->next = NULL;

    return newNode;
}
```

## 2. `void insAtStart(**head, item)`
### Algorithm
- Step 1: Create a new node with `item` as its data value.
- Step 2: If the list is empty, make the new node the new head node.
	- print an "inserted at start" statement.
- Step 3: If the list contains some nodes,
	- make the new node point forward to `head`.
	- make `head` point backward to the new node
	- make the new node the new head node
	- print an "inserted at start" statement.
### Code

``` c
void insAtStart(Node **head, int item)
{
    Node *newNode = createNode(item);

    if (*head == NULL)
    {
        *head = newNode;
        printf("Inserted %d at start (first node).\n", item);
        return;
    }

    newNode->next = *head;   // head is after newNode
    (*head)->prev = newNode; // newNode is before head
    *head = newNode;         // newNode becomes head
    // NULL <-> newNode >-> head

    printf("Inserted %d at start.\n", item);
}
```

## 3. `void insAtPos(**head, pos, item)`
### Algorithm
- Step 1: If `pos` is less than 1, print an "invalid position" statement and return control.
- Step 2: If `pos` is 1, insert a new node at the start of the list and return control.
- Step 3: If `pos` has any other value,
	- create a traversal node and assign `head` to it.
	- traverse the list from position 1 to one position before `pos`.
	- if the position does not exist in the list, print an "invalid position" statement and return control.
	- if the position is valid,
		- create a new node with `item` as its data value.
		- create a node pointer (`targetNode`) that points to the node after the traversal node.
		- point the new node forward to the `targetNode`.
		- point the new node backward to the traversal node.
		- if the traversal node is not null, point `targetNode` forward to the new node.
		- make the traversal node point forward to the new node
		- printed an "inserted at position" statement.
### Code

``` c
void insAtPos(Node **head, int pos, int item)
{
    if (pos < 1)
    {
        printf("Invalid position.\n");
        return;
    }

    if (pos == 1)
    {
        insAtStart(head, item);
        return;
    }

    Node *prevNode = *head;
    for (int i = 1; i < pos - 1 && prevNode != NULL; i++)
        prevNode = prevNode->next;
    // prevNode is now the node just before the target node

    if (prevNode == NULL)
    {
        printf("Invalid position.\n");
        return;
    }

    Node *newNode = createNode(item);
    Node *targetNode = prevNode->next;
    newNode->next = targetNode; // targetNode is after newNode
    newNode->prev = prevNode;   // prevNode is before newNode

    if (targetNode != NULL)
        targetNode->prev = newNode; // newNode is before targetNode
    prevNode->next = newNode;       // newNode is after prevNode
    // prevNode <-> newNode <-> targetNode

    printf("Inserted %d at position %d.\n", item, pos);
}
```

## 4. `void delByValue(**head, item)`
- Step 1: If the list is empty, print an "empty" statement and return control.
- Step 2: If the list contains some nodes,
	- create a traversal node pointer (`targetNode`) and assign `head` to it.
	- traverse through the list till the node with the desired value is reached
	- if the node does not exist, print an "item not found" statement and return control.
	- create a node pointer (`nextNode`) and assign the node after the traversal node to it.
	- create another node pointer (`prevNode`) and assign the node before the traversal node to it.
	- if `targetNode` is the head node, make the node after it the new head
		- if the new head node exists, make it point backwards to null.
	- if `targetNode` is any other node, make the node before it point forwards to the node after it.
	- if the node after `targetNode` is not the last node, make it point backwards to the node before `targetNode`
	- free the memory at `targetNode`'s address.
	- print a "deleted value node" statement.
### Code

``` c
void delByValue(Node **head, int item)
{
    if (*head == NULL)
    {
        printf("List is empty.\n");
        return;
    }

    Node *targetNode = *head;

    // search for the node
    while (targetNode != NULL && targetNode->data != item)
        targetNode = targetNode->next;

    // item not found
    if (targetNode == NULL)
    {
        printf("Item not found.\n");
        return;
    }

    // if targetNode is head
    if (targetNode->prev == NULL)
    {
        *head = targetNode->next;
        if (*head != NULL)
            (*head)->prev = NULL;
    }
    
    else
        (targetNode->prev)->next = targetNode->next;
    // if targetNode is not the last node
    if (targetNode->next != NULL)
        (targetNode->next)->prev = targetNode->prev;

    free(targetNode);
    printf("Deleted value %d node.\n", item);
}
```

## 5. `void displayList(*head)`
### Algorithm
- Step 1: If the list is empty, print an "empty list" statement and return control.
	- alternatively, print a list with null as the only value in it.
- Step 2: If the list contains some nodes,
	- create a traversal node pointer and assign `head` to it.
	- traverse through the list and print the data values of all the nodes one by one.
	- print null as the last value being pointed to.
### Code

``` c
void displayList(Node *head)
{
    if (head == NULL)
    {
        printf("\nList: \nNULL");
        return;
    }

    Node *temp = head;
    printf("\nList:\n");
    while (temp != NULL)
    {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
```


# Complete Program

``` c
#include <stdio.h>
#include <stdlib.h>

// node implementation
typedef struct Node
{
    int data;
    struct Node *prev;
    struct Node *next;
} Node;

// creating a node
Node *createNode(int item)
{
    Node *newNode = (Node *)malloc(sizeof(Node));

    if (newNode == NULL)
    {
        printf("Error:Memory allocation failed.\n");
        exit(1);
    }

    newNode->data = item;
    newNode->prev = NULL;
    newNode->next = NULL;

    return newNode;
}

// insert a node at the start of the list
void insAtStart(Node **head, int item)
{
    Node *newNode = createNode(item);

    if (*head == NULL)
    {
        *head = newNode;
        printf("Inserted %d at start (first node).\n", item);
        return;
    }

    newNode->next = *head;   // head is after newNode
    (*head)->prev = newNode; // newNode is before head
    *head = newNode;         // newNode becomes head
    // NULL <-> newNode >-> head

    printf("Inserted %d at start.\n", item);
}

// insert a node at the left of a given node
void insAtLeft(Node **head, int pos, int item)
{
    if (pos < 1)
    {
        printf("Invalid position.\n");
        return;
    }

    if (pos == 1)
    {
        insAtStart(head, item);
        return;
    }

    Node *prevNode = *head;
    for (int i = 1; i < pos - 1 && prevNode != NULL; i++)
        prevNode = prevNode->next;
    // prevNode is now the node just before the target node

    if (prevNode == NULL)
    {
        printf("Invalid position.\n");
        return;
    }

    Node *newNode = createNode(item);
    Node *targetNode = prevNode->next;
    newNode->next = targetNode; // targetNode is after newNode
    newNode->prev = prevNode;   // prevNode is before newNode

    if (targetNode != NULL)
        targetNode->prev = newNode; // newNode is before targetNode
    prevNode->next = newNode;       // newNode is after prevNode
    // prevNode <-> newNode <-> targetNode

    printf("Inserted %d at position %d.\n", item, pos);
}

// delete a node by value
void delByValue(Node **head, int item)
{
    if (*head == NULL)
    {
        printf("List is empty.\n");
        return;
    }

    Node *targetNode = *head;

    // search for the node
    while (targetNode != NULL && targetNode->data != item)
        targetNode = targetNode->next;

    // item not found
    if (targetNode == NULL)
    {
        printf("Item not found.\n");
        return;
    }

    // if targetNode is head
    if (targetNode->prev == NULL)
    {
        *head = targetNode->next;
        if (*head != NULL)
            (*head)->prev = NULL;
    }

    else
        (targetNode->prev)->next = targetNode->next;
    // if targetNode is not the last node
    if (targetNode->next != NULL)
        (targetNode->next)->prev = targetNode->prev;

    free(targetNode);
    printf("Deleted value %d node.\n", item);
}

// display nodes in the list
void displayList(Node *head)
{
    if (head == NULL)
    {
        printf("\nList: \nNULL");
        return;
    }

    Node *temp = head;
    printf("\nList:\n");
    while (temp != NULL)
    {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

int main()
{
    Node *head = NULL;

    printf("-- Doubly Linked List Operations -----\n");

    printf("\n--- Insert At Start ---\n");
    insAtStart(&head, 30);
    insAtStart(&head, 20);
    insAtStart(&head, 10);
    displayList(head);

    printf("\n--- Insert At Left ---\n");
    insAtLeft(&head, 2, 15);
    displayList(head);

    insAtLeft(&head, 5, 40);
    displayList(head);

    printf("\n--- Delete By Value ---\n");
    delByValue(&head, 20);
    displayList(head);

    return 0;
}
```

## Output

```
----- Doubly Linked List Operations -----

--- Insert At Start ---
Inserted 30 at start (first node).
Inserted 20 at start.
Inserted 10 at start.

List:
10 <-> 20 <-> 30 <-> NULL

--- Insert At Left ---
Inserted 15 at position 2.

List:
10 <-> 15 <-> 20 <-> 30 <-> NULL
Inserted 40 at position 5.

List:
10 <-> 15 <-> 20 <-> 30 <-> 40 <-> NULL

--- Delete By Value ---
Deleted value 20 node.

List:
10 <-> 15 <-> 30 <-> 40 <-> NULL
```


